"use strict";(self.webpackChunktest_site=self.webpackChunktest_site||[]).push([[6737],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>m});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var c=n.createContext({}),s=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},u=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=s(a),p=o,m=d["".concat(c,".").concat(p)]||d[p]||h[p]||i;return a?n.createElement(m,r(r({ref:t},u),{},{components:a})):n.createElement(m,r({ref:t},u))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=a.length,r=new Array(i);r[0]=p;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[d]="string"==typeof e?e:o,r[1]=l;for(var s=2;s<i;s++)r[s]=a[s];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},26597:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var n=a(87462),o=(a(67294),a(3905));const i={sidebar_label:"Understanding Trial Accounts"},r="Basis of Trial Accounts",l={unversionedId:"TrialAccounts/Creation/understanding-trial-accounts",id:"version-2.0/TrialAccounts/Creation/understanding-trial-accounts",title:"Basis of Trial Accounts",description:"A Trial Account is simply an account on NEAR that has a set of pre-defined restrictions that limit the methods that it can call. This is achieved by deploying a very small no-std Rust smart contract on it (~25 kb or 0.25 $NEAR) that acts as a proxy, or middleman, for any outbound calls it makes.",source:"@site/versioned_docs/version-2.0/TrialAccounts/Creation/understanding-trial-accounts.md",sourceDirName:"TrialAccounts/Creation",slug:"/TrialAccounts/Creation/understanding-trial-accounts",permalink:"/docs/2.0/TrialAccounts/Creation/understanding-trial-accounts",draft:!1,editUrl:"https://github.com/keypom/keypom-docs/tree/main/versioned_docs/version-2.0/TrialAccounts/Creation/understanding-trial-accounts.md",tags:[],version:"2.0",frontMatter:{sidebar_label:"Understanding Trial Accounts"},sidebar:"TrialAccounts",previous:{title:"Before You Begin",permalink:"/docs/2.0/TrialAccounts/Creation/getting-started"},next:{title:"Create Your First Drop",permalink:"/docs/2.0/TrialAccounts/Creation/drop-creation"}},c={},s=[{value:"Keypom Drops",id:"keypom-drops",level:2},{value:"Understanding Trial Restrictions",id:"understanding-trial-restrictions",level:2},{value:"Callable Contracts",id:"callable-contracts",level:3},{value:"Callable Methods",id:"callable-methods",level:3},{value:"Max Attachable Deposit",id:"max-attachable-deposit",level:3},{value:"Exit Conditions",id:"exit-conditions",level:2},{value:"Trial Over Floor",id:"trial-over-floor",level:3},{value:"Repay Conditions",id:"repay-conditions",level:3},{value:"What Happens On Exit?",id:"what-happens-on-exit",level:3},{value:"Conclusion",id:"conclusion",level:2}],u={toc:s},d="wrapper";function h(e){let{components:t,...i}=e;return(0,o.kt)(d,(0,n.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"basis-of-trial-accounts"},"Basis of Trial Accounts"),(0,o.kt)("p",null,"A Trial Account is simply an account on NEAR that has a set of pre-defined restrictions that limit the methods that it can call. This is achieved by deploying a very small no-std Rust smart contract on it (~25 kb or 0.25 $NEAR) that acts as a proxy, or middleman, for any outbound calls it makes."),(0,o.kt)("p",null,"The contract deployed to the account exposes a method ",(0,o.kt)("inlineCode",{parentName:"p"},"execute")," that takes a set of actions as arguments, checks whether the actions are allowed, and then executes them. To achieve this middleman behavior, the Trial Account cannot have any full access keys (otherwise it could bypass the ",(0,o.kt)("inlineCode",{parentName:"p"},"execute")," method, and in turn, the restrictions). The account should ",(0,o.kt)("em",{parentName:"p"},"only")," have one limited access key that can call the ",(0,o.kt)("inlineCode",{parentName:"p"},"execute")," method on its own contract."),(0,o.kt)("p",null,"Whenever a Trial Account wants to call a method on an external contract, say ",(0,o.kt)("inlineCode",{parentName:"p"},"nft_mint")," on the ",(0,o.kt)("inlineCode",{parentName:"p"},"nft.examples.testnet")," account, it needs to call ",(0,o.kt)("inlineCode",{parentName:"p"},"execute")," and pass in the desired function call as arguments. The contract will then check whether those actions are allowed and if they are, it will execute the desired behavior."),(0,o.kt)("p",null,"To help illustrate this behavior, the follow diagram shows the above scenario."),(0,o.kt)("p",{align:"center"},(0,o.kt)("img",{src:a(3078).default,width:"40%",height:"15%",alt:"ticketing"})),(0,o.kt)("h2",{id:"keypom-drops"},"Keypom Drops"),(0,o.kt)("p",null,"From the above, a Trial Account can be created by deployed a valid contract to an account that only has a limited access key on it with the correct permissions. This can all be achieved with a ",(0,o.kt)("a",{parentName:"p",href:"/docs/2.0/Concepts/KeypomProtocol/GithubReadme/TypesOfDrops/fc-drops"},"Function Call drop"),"."),(0,o.kt)("p",null,"In order to create accounts ending with ",(0,o.kt)("inlineCode",{parentName:"p"},".near")," or ",(0,o.kt)("inlineCode",{parentName:"p"},".testnet"),", you'll need the ",(0,o.kt)("inlineCode",{parentName:"p"},"near")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"testnet")," accounts to create sub-accounts. This is done by calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"create_account")," function on their contracts (the code is found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/near/near-linkdrop/blob/49279e529c254fa7736465b4a39d05cb8f1e5443/src/lib.rs#L130"},"here"),"). This is exactly how regular linkdrops work, including ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/keypom/keypom/blob/7a654aa847f2ce9dedf65755c6a08817eece4666/contract/src/stage3/claim.rs#L129"},"Keypom"),"."),(0,o.kt)("p",null,"By calling ",(0,o.kt)("inlineCode",{parentName:"p"},"create_account"),", a new sub-account is created with a full access key. This is close to the behavior we want for Trial Accounts but not exactly. In order to create a new account that has a limited access key and a contract deployed, you can call the ",(0,o.kt)("inlineCode",{parentName:"p"},"create_account_advanced")," function instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"create_account"),", code found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/near/near-linkdrop/blob/49279e529c254fa7736465b4a39d05cb8f1e5443/src/lib.rs#L156"},"here"),". This function can accept ",(0,o.kt)("inlineCode",{parentName:"p"},"wasm")," for a contract, and limited access key arguments."),(0,o.kt)("p",null,"A Keypom function call drop can then be programmed to:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Call the ",(0,o.kt)("inlineCode",{parentName:"li"},"create_account_advanced")," function."),(0,o.kt)("li",{parentName:"ul"},"Pass in user provided args for the new account ID."),(0,o.kt)("li",{parentName:"ul"},"Pass in the ",(0,o.kt)("inlineCode",{parentName:"li"},"wasm")," for the contract to be deployed."),(0,o.kt)("li",{parentName:"ul"},"Pass in the limited access key arguments to create a key that can call ",(0,o.kt)("inlineCode",{parentName:"li"},"execute")," on the newly created account."),(0,o.kt)("li",{parentName:"ul"},"Once the account is created, Keypom will automatically call a setup method on the new account that will set the restrictions.")),(0,o.kt)("p",null,"Keypom has abstracted away all these complexities using a simple ready-made function ",(0,o.kt)("a",{parentName:"p",href:"/docs/2.0/keypom-sdk/Core/modules#createtrialaccountdrop"},"createTrialAccountDrop"),"."),(0,o.kt)("h2",{id:"understanding-trial-restrictions"},"Understanding Trial Restrictions"),(0,o.kt)("p",null,"There are 3 different restrictions that can be applied to a Trial Account:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Callable contracts"),(0,o.kt)("li",{parentName:"ul"},"Callable methods"),(0,o.kt)("li",{parentName:"ul"},"Attached Deposits")),(0,o.kt)("h3",{id:"callable-contracts"},"Callable Contracts"),(0,o.kt)("p",null,"As a trial funder, you have complete control over exactly which contracts a trial account can call. This can be any number of contracts and should be passed in using an array. For example, if you wanted the trial to only call methods on the ",(0,o.kt)("inlineCode",{parentName:"p"},"v2.keypom.testnet")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"nft.examples.testnet")," contracts, you would pass in the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const callableContracts = [\n  "v2.keypom.testnet",\n  "nft.examples.testnet"\n]\n')),(0,o.kt)("h3",{id:"callable-methods"},"Callable Methods"),(0,o.kt)("p",null,"Not only do you have full control over the contracts that a trial account can call, but you can also specify individual methods on a per-contract basis. In the above example, if you wanted the account to be able to call any method on the ",(0,o.kt)("inlineCode",{parentName:"p"},"v2.keypom.testnet")," contract, but only the ",(0,o.kt)("inlineCode",{parentName:"p"},"nft_mint")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"nft_transfer")," methods on the ",(0,o.kt)("inlineCode",{parentName:"p"},"nft.examples.testnet")," contract, you would pass in the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const callableMethods = [\n  ["*"],\n  ["nft_mint", "nft_transfer"]\n]\n')),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"*")," symbol is used to represent no restrictions on methods for a given contract.")),(0,o.kt)("h3",{id:"max-attachable-deposit"},"Max Attachable Deposit"),(0,o.kt)("p",null,"The last restriction that you can set on a given trial account is the maximum amount of $NEAR that can be attached to function calls for a given contract. In the above scenario, say you wanted to limit an account to the following restrictions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Attaching up to 5 $NEAR to any method on the ",(0,o.kt)("inlineCode",{parentName:"li"},"v2.keypom.testnet")," contract."),(0,o.kt)("li",{parentName:"ul"},"Only attaching 1 yoctoNEAR to methods on the ",(0,o.kt)("inlineCode",{parentName:"li"},"nft.examples.testnet")," contract.")),(0,o.kt)("p",null,"You would pass in the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const maxAttachableDeposit = [\n  "5000000000000000000000000",\n  "1"\n]\n')),(0,o.kt)("h2",{id:"exit-conditions"},"Exit Conditions"),(0,o.kt)("p",null,"The final thing to understand about trial accounts is how they can be exited. While the account is in the trial state, it has restrictions and isn't usable in the wider ecosystem. As a funder, you can specify conditions that need to be met in order for the account to exit the trial state."),(0,o.kt)("h3",{id:"trial-over-floor"},"Trial Over Floor"),(0,o.kt)("p",null,"The main condition that dictates how long an account will be in the trial state before it must exit is the trial floor. This is an amount of $NEAR that must be spent before the account is eligible to exit. The amount consists of both gas burnt as well as deposits to successful function calls."),(0,o.kt)("p",null,"For example, if an account attached 1 $NEAR to a function call and also burnt 75 TGas, it would be ",(0,o.kt)("inlineCode",{parentName:"p"},"1.0075 $NEAR")," closer to the floor. Overtime, as an account executes more and more transactions, it will come closer to the floor. Once the floor has been reached, the account will be eligible to exit."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"It's important to note that once the floor has been met, the account can continue to execute transactions. Reaching the floor simply means that the account ",(0,o.kt)("em",{parentName:"p"},"can")," exit the trial state (assuming all other conditions have been met).")),(0,o.kt)("h3",{id:"repay-conditions"},"Repay Conditions"),(0,o.kt)("p",null,"If the funder chooses to, they can also specify a repay condition. This is an amount of $NEAR that must be paid back to them in order for the account to exit the trial state. "),(0,o.kt)("p",null,"This process happens automatically when the exit method is called but it will throw an error if the  account doesn't possess enough funds to repay the funder. This amount can be 0 $NEAR meaning that once the account reaches the floor, it can immediately exit without needing to repay."),(0,o.kt)("p",null,"The $NEAR needed to repay the funder can be gained in one of three ways:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Gained during the trial (e.g selling an NFT you minted, winning an on-chain lottery etc.)."),(0,o.kt)("li",{parentName:"ol"},"Sent by another account."),(0,o.kt)("li",{parentName:"ol"},"Sent with an on-ramp (similar to how accounts are funded currently).")),(0,o.kt)("p",null,"While there is still friction in the last case, the user has ",(0,o.kt)("strong",{parentName:"p"},"experienced your application first")," and the onboarding is pushed until after their trial is over. Currently, people need to go through the complicated onboarding process first and only experience the app afterwards."),(0,o.kt)("p",null,"As an example, let's say you're building a roulette app and you want to give users a trial account to experience what you're building in the hope that they will continue to use it afterwards. You give someone 10 $NEAR and set a repay condition of 5 $NEAR. During their trial, they could have won 20 $NEAR from the roulette app by putting all their money on red."),(0,o.kt)("p",null,"This would satisfy the repay condition and they would be able to keep the rest of the $NEAR that they won."),(0,o.kt)("h3",{id:"what-happens-on-exit"},"What Happens On Exit?"),(0,o.kt)("p",null,"When regular accounts are created on NEAR, they start with a full access key and don't have any smart contract deployed to them. This behavior should be the same for trial accounts except they keep any assets they had during the trial state. When the account exits, the following will happen:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The limited access key is removed from the account."),(0,o.kt)("li",{parentName:"ul"},"The trial contract is removed from the account."),(0,o.kt)("li",{parentName:"ul"},"Any state that was set on the trial contract is removed."),(0,o.kt)("li",{parentName:"ul"},"The full access key is added to the account."),(0,o.kt)("li",{parentName:"ul"},"Any repay conditions are paid out."),(0,o.kt)("li",{parentName:"ul"},"Any $NEAR that was ",(0,o.kt)("em",{parentName:"li"},"not")," gained during the trial is returned to the funder. This includes the bytes freed from deleting the contract and is meant to be a way to resist Sybil attacks.")),(0,o.kt)("p",null,"This means that the account will act as a fresh NEAR account with a set of starting assets such as NFTs or FTs that it gained during the trial. If the account wanted to, it could deploy a contract such as multi-sig, nETH etc."),(0,o.kt)("p",null,"When a trial account exits, it will be given a full access key and the restrictions will be removed. This means that the account will be able to call any method on any contract and attach any amount of $NEAR to function calls."),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"In this tutorial, you learnt the basics of how trial accounts operate and what is needed to create them. You also learnt about the different restrictions that can be applied to trial accounts, how they can be exited and what happens when they exit."),(0,o.kt)("p",null,"In the next tutorial, you'll learn how to create a simple trial account drop that will be used to instantly sign a user into the guest-book application."))}h.isMDXComponent=!0},3078:(e,t,a)=>{a.r(t),a.d(t,{default:()=>n});const n=a.p+"assets/images/trial-account-execute-flow-6960ca3742a13b002248a1a3848c3b2b.png"}}]);