"use strict";(self.webpackChunktest_site=self.webpackChunktest_site||[]).push([[9326],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=r.createContext({}),u=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(i.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(n),h=a,m=p["".concat(i,".").concat(h)]||p[h]||d[h]||o;return n?r.createElement(m,s(s({ref:t},c),{},{components:n})):r.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=h;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l[p]="string"==typeof e?e:a,s[1]=l;for(var u=2;u<o;u++)s[u]=n[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>s});var r=n(67294),a=n(86010);const o={tabItem:"tabItem_Ymn6"};function s(e){let{children:t,hidden:n,className:s}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(o.tabItem,s),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>v});var r=n(87462),a=n(67294),o=n(86010),s=n(12466),l=n(16550),i=n(91980),u=n(67392),c=n(50012);function p(e){return function(e){return a.Children.map(e,(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:a}}=e;return{value:t,label:n,attributes:r,default:a}}))}function d(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??p(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function h(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const r=(0,l.k6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,i._X)(o),(0,a.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(r.location.search);t.set(o,e),r.replace({...r.location,search:t.toString()})}),[o,r])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,o=d(e),[s,l]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:o}))),[i,u]=m({queryString:n,groupId:r}),[p,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,o]=(0,c.Nk)(n);return[r,(0,a.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:r}),y=(()=>{const e=i??p;return h({value:e,tabValues:o})?e:null})();(0,a.useLayoutEffect)((()=>{y&&l(y)}),[y]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!h({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),f(e)}),[u,f,o]),tabValues:o}}var y=n(72389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function k(e){let{className:t,block:n,selectedValue:l,selectValue:i,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:p}=(0,s.o5)(),d=e=>{const t=e.currentTarget,n=c.indexOf(t),r=u[n].value;r!==l&&(p(t),i(r))},h=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:s}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:e=>c.push(e),onKeyDown:h,onClick:d},s,{className:(0,o.Z)("tabs__item",b.tabItem,s?.className,{"tabs__item--active":l===t})}),n??t)})))}function g(e){let{lazy:t,children:n,selectedValue:r}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},o.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==r}))))}function w(e){const t=f(e);return a.createElement("div",{className:(0,o.Z)("tabs-container",b.tabList)},a.createElement(k,(0,r.Z)({},e,t)),a.createElement(g,(0,r.Z)({},e,t)))}function v(e){const t=(0,y.Z)();return a.createElement(w,(0,r.Z)({key:String(t)},e))}},56880:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>u,toc:()=>p});var r=n(87462),a=(n(67294),n(3905)),o=n(74866),s=n(85162);const l={sidebar_label:"Fungible Token Drops",sidebar_position:4},i="Fungible Token Drops",u={unversionedId:"Concepts/KeypomProtocol/GithubReadme/TypesOfDrops/ft-drops",id:"Concepts/KeypomProtocol/GithubReadme/TypesOfDrops/ft-drops",title:"Fungible Token Drops",description:"A Fungible Token drop is also a light wrapper around the simple drop. It works very similarly to how its NFT",source:"@site/docs/Concepts/KeypomProtocol/GithubReadme/TypesOfDrops/ft-drops.md",sourceDirName:"Concepts/KeypomProtocol/GithubReadme/TypesOfDrops",slug:"/Concepts/KeypomProtocol/GithubReadme/TypesOfDrops/ft-drops",permalink:"/docs/Concepts/KeypomProtocol/GithubReadme/TypesOfDrops/ft-drops",draft:!1,editUrl:"https://github.com/keypom/keypom-docs/tree/main/docs/Concepts/KeypomProtocol/GithubReadme/TypesOfDrops/ft-drops.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_label:"Fungible Token Drops",sidebar_position:4}},c={},p=[{value:"How does it work?",id:"how-does-it-work",level:2},{value:"FT Config",id:"ft-config",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"Recurring Payments",id:"recurring-payments",level:3},{value:"Backend Servers",id:"backend-servers",level:3},{value:"Creating a Wallet with FTs",id:"creating-a-wallet-with-fts",level:3}],d={toc:p},h="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(h,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"fungible-token-drops"},"Fungible Token Drops"),(0,a.kt)("p",null,"A Fungible Token drop is also a light wrapper around the simple drop. It works very similarly to how its NFT\ncounterpart does. First, you'll need to create the drop and then you can fund it with assets and register\nkey uses."),(0,a.kt)("p",null,"You can preload a drop with as many FTs as you'd like even if you don't have the keys yet. This will spike the\n",(0,a.kt)("inlineCode",{parentName:"p"},"registered_uses"),' and then you can create keys and slowly eat away from this "total supply" overtime. If the\ndrop runs out, you can send it more FTs to top up. All the keys in the FT drop will share from this supply\nand every time a key is used, the ',(0,a.kt)("inlineCode",{parentName:"p"},"registered_uses"),' will decrement and the "total supply" will get smaller.'),(0,a.kt)("h2",{id:"how-does-it-work"},"How does it work?"),(0,a.kt)("p",null,"As mentioned in the NFT section, every drop has a field known as ",(0,a.kt)("inlineCode",{parentName:"p"},"registered_uses"),". This tells the contract\nhow many uses the drop has across all its keys. For simple drops, this field doesn't matter since all the uses\nare paid for up-front when the drop is created or when keys are added. With FT drops, however,\nthere is a 2 step process:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Firstly, the drop is created and all the $NEAR required is pre-paid for. This is the same as\nsimple drops, however, the ",(0,a.kt)("inlineCode",{parentName:"li"},"registered_uses")," are set to 0."),(0,a.kt)("li",{parentName:"ul"},"Once the drop is created, the owner must send the contract the FTs in order for keys to be\nusable. This process is done through the ",(0,a.kt)("inlineCode",{parentName:"li"},"ft_transfer_call")," workflow baked into the FT standards.\nIt's up to the owner to facilitate this process.")),(0,a.kt)("h2",{id:"ft-config"},"FT Config"),(0,a.kt)("p",null,"Along with the default global configurations for drops, if you'd like to create a FT drop,\nyou must specify the following pieces of information when the drop is created."),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"KPJS",label:"\ud83d\udd11 Keypom SDK",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"reference",reference:!0},"https://github.com/keypom/keypom-js/blob/e8c43f4219a79afb3c367296cc90b8d5de977945/src/lib/types/ft.ts#L4-L23\n"))),(0,a.kt)(s.Z,{value:"KP",label:"\ud83d\udcda Protocol",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:"reference",reference:!0},"https://github.com/keypom/keypom/blob/7a654aa847f2ce9dedf65755c6a08817eece4666/contract/src/models/json_types.rs#L119-L123\n")))),(0,a.kt)("p",null,"By specifying this information, the drop is locked into only accepting FTs coming from the sender and contract. While\nyou can send as many FTs as you'd like and can over-pay, you ",(0,a.kt)("em",{parentName:"p"},"must")," send at ",(0,a.kt)("strong",{parentName:"p"},"least")," enough FTs in one call to cover\n1 use. As an example, if a drop is created such that 10 FTs will be sent when a key is used, you must send ",(0,a.kt)("strong",{parentName:"p"},"at least 10"),"\nand cannot break it up into separate calls where you send 5 one time and 5 another."),(0,a.kt)("h2",{id:"use-cases"},"Use Cases"),(0,a.kt)("p",null,"FT drops have some awesome flexibility due to the fact that they support all the functionalities of the Simple drops, just with\nmore use-cases and possibilities. Let's look at some use cases to see how fungible token drops can be used."),(0,a.kt)("h3",{id:"recurring-payments"},"Recurring Payments"),(0,a.kt)("p",null,"Recurring payments are quite a common situation. Let's say you need to send someone $50 USDC every week. You\ncould create a key with 5 claims that has a claim_interval` of 1 week. You would then pre-load maybe the\nfirst week's deposit of $50 USDC and register 1 use or you could send $500 USDC for the first 10 weeks. At that\npoint, you would simply hand over the key to the user and they can claim once a week."),(0,a.kt)("h3",{id:"backend-servers"},"Backend Servers"),(0,a.kt)("p",null,"Taking the recurring payments problem to another level, imagine that instead of leaving the claims up to the\ncontractor, you wanted to automatically pay them through a backend server. They would give you their NEAR account\nand you would send them FTs. The problem is that you don't want to expose your full access key in the server.\nBy creating a FT drop, you can store ",(0,a.kt)("strong",{parentName:"p"},"only the function call access key")," created by Keypom in the server.\nYour backend would them use the key to call the ",(0,a.kt)("inlineCode",{parentName:"p"},"claim")," function and pass in the user's account ID to send\nthem the FTs."),(0,a.kt)("h3",{id:"creating-a-wallet-with-fts"},"Creating a Wallet with FTs"),(0,a.kt)("p",null,"Another awesome use-case is to allow users to be onboarded onto NEAR and ",(0,a.kt)("strong",{parentName:"p"},"also")," receive FTs. As an example,\nYou could do a promotion where you're giving away $10 USDC to the first 100 users that sign up to your mailing\nlist. You can also give away QR codes at events that contain a new fungible token that you're launching. You can\nsimply create a FT drop and pre-load it with the FT of your choice. In addition, you can give it 0.02 $NEAR for\nnew wallets that are created."),(0,a.kt)("p",null,"You can pair this with setting the ",(0,a.kt)("inlineCode",{parentName:"p"},"on_claim_refund_deposit")," flag to true which would make it so that if anyone claims\nthe fungible tokens and they ",(0,a.kt)("em",{parentName:"p"},"already have a wallet"),", it will automatically refund you the 0.02 $NEAR. That money should\nonly be used for the creation of new wallets. Since your focus is on the fungible tokens, you don't want to ",(0,a.kt)("strong",{parentName:"p"},"force users"),"\nto create a new wallet if they have one already by specifying the claim permission to be ",(0,a.kt)("inlineCode",{parentName:"p"},"CreateAccountAndClaim")," but instead,\nyou want to be refunded in case they do."))}m.isMDXComponent=!0}}]);